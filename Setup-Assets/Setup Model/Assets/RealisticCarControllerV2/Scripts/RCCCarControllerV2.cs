//----------------------------------------------
//            Realistic Car Controller
//
// Copyright Â© 2015 BoneCracker Games
// http://www.bonecrackergames.com
//
//----------------------------------------------

#pragma warning disable 0414

using UnityEngine;
using UnityEngine.Audio;
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;
using UnityEngine.EventSystems;

[RequireComponent (typeof(Rigidbody))]
public class RCCCarControllerV2 : MonoBehaviour {

	private Rigidbody rigid;		// Rigidbody.
	internal bool sleepingRigid = false;		// Used For Disabling Unnecessary Raycasts When RB Is Sleeping.

	// Mobile Controller.
	public bool mobileController = false;
	public MobileGUIType _mobileControllerType;
	public enum MobileGUIType{UIController, NGUIController}

	public bool AIController = false;		// Use AI Controller.
	
	// Dashboard Type.
	public bool dashBoard = false;
	public DashboardType _dashboardType;
	public enum DashboardType{UIDashboard, NGUIDashboard}
	
	public bool useAccelerometerForSteer = false, steeringWheelControl = false;		// Use Accelerometer Or Steering Wheel Controlling For Mobile Use.
	public float gyroTiltMultiplier = 2f;		// Gyro Sensitivity.
	
	public bool demoGUI = false;		// Display Information GUI.
	public bool showMobileControllerChangerButtons = false;		// Display Mobile Controller Changer Buttons GUI.
	private Vector3 defbrakePedalPosition;		// Caching Default Brake Pedal Position In Case Of Using Accelerometer.
	public bool autoFindButtons = true;		// Finds all buttons when new vehicle spawned. Useful for spawning new vehicles on your scene at runtime.
	
	// NGUI Controller Elements.
	public RCCNGUIController gasPedalNGUI, brakePedalNGUI, leftArrowNGUI, rightArrowNGUI, handbrakeNGUI, boostNGUI;		// If boost UI is selected, will multiply default engine torque by 2.5.
	// UI Controller Elements.
	public RCCUIController gasPedalUI, brakePedalUI, leftArrowUI, rightArrowUI, handbrakeUI, boostUI;		// If boost UI is selected, will multiply default engine torque by 2.5.
	
	// Wheel Transforms Of The Vehicle.
	public Transform FrontLeftWheelTransform;
	public Transform FrontRightWheelTransform;
	public Transform RearLeftWheelTransform;
	public Transform RearRightWheelTransform;
	
	// Wheel Colliders Of The Vehicle.
	public WheelCollider FrontLeftWheelCollider;
	public WheelCollider FrontRightWheelCollider;
	public WheelCollider RearLeftWheelCollider;
	public WheelCollider RearRightWheelCollider;

	// All Wheel Colliders.
	private WheelCollider[] allWheelColliders;

	// Wheel Friction Curves.
	private WheelFrictionCurve sidewaysFriction;
	private WheelFrictionCurve forwardFriction;
	
	// Extra Wheels. In case of if your vehicle has extra wheels.
	public Transform[] ExtraRearWheelsTransform;
	public WheelCollider[] ExtraRearWheelsCollider;
	
	public bool applyEngineTorqueToExtraRearWheelColliders = true;		//Applies Engine Torque To Extra Rear Wheels.

	public Transform SteeringWheel;		// Driver Steering Wheel. In case of if your vehicle has individual steering wheel model in interior.
	
	// Set wheel drive of the vehicle. If you are using rwd, you have to be careful with your rear wheel collider
	// settings and com of the vehicle. Otherwise, vehicle will behave like a toy.
	public WheelType _wheelTypeChoise = WheelType.RWD;
	public enum WheelType{FWD, RWD, AWD, DRIFT}
	
	//Center of mass.
	public Transform COM;
	
	public bool canControl = true;		// Enables/Disables controlling the vehicle.
	public bool runEngineAtAwake = true;		// Engine Running At Awake?
	public bool canEngineStall = true;		// Engine Stalls If Engine RPM Is Lower Then Minimum Engine RPM / 2.
	public bool engineRunning = false;		// Engine Running Now?
	public bool autoReverse = true;		// Enables/Disables auto reversing when player press brake button. Useful for if you are making parking style game.
	public bool automaticGear = true;		// Enables/Disables automatic gear shifting of the vehicle.
	private bool canGoReverseNow = false;
	
	public AnimationCurve[] engineTorqueCurve;		// Each Gear Ratio Curves Generated By Editor Script.
	public float[] gearSpeed;		// Target Speed For Changing Gear.
	public float engineTorque = 3000f;		// Default Engine Torque.
	public float maxEngineRPM = 7000f;		// Maximum Engine RPM.
	public float minEngineRPM = 1000f;		// Minimum Engine RPM.
	
	public float steerAngle = 40f;		// Maximum Steer Angle Of Your Vehicle.
	public float highspeedsteerAngle = 10f;		// Maximum Steer Angle At Highest Speed.
	public float highspeedsteerAngleAtspeed = 80f;		// Highest Speed For Maximum Steer Angle.
	public float antiRoll = 5000f;		// Anti Roll Force For Preventing Flip Overs And Stability.

	//Downforce.
	public float downForce = 25f;		// Applies Downforce Releated With Vehicle Speed.

	public float speed;		// Vehicle Speed as KM/H.
	public float brake = 4000f;		// Maximum Brake Torque.
	public float maxspeed = 220f;		//Maximum Speed.

	private float resetTime = 0f;
	private float defSteerAngle = 0f;
	
	// Gears.
	public int currentGear;		// Current Gear Of The Vehicle.
	public int totalGears = 6;			// Total Gears Of The Vehicle.
	[Range(0f, .5f)]public float gearShiftingDelay = .35f;
	public bool changingGear = false;		// Changing Gear Currently.
	public bool reverseGear = false;		// Reverse Gear Currently.

	public bool autoGenerateGearCurves = true;
	public bool autoGenerateTargetSpeedsForChangingGear = true;
	
	// Each Wheel Transform's Rotation Value.
	private float _rotationValueFL, _rotationValueFR, _rotationValueRL, _rotationValueRR;
	private float[] _rotationValueExtra;
	
	// Private Bools.
	private float acceleration = 0f;
	private float lastVelocity = 0f;
	private bool engineStarting = false;
	
	//AudioSources and AudioClips.
	private AudioSource engineStartSound;
	public AudioClip engineStartClip;
	private AudioSource engineSoundOn;
	public AudioClip engineClipOn;
	private AudioSource engineSoundOff;
	public AudioClip engineClipOff;
	private AudioSource gearShiftingSound;
	public AudioClip[] gearShiftingClips;
	private AudioSource crashSound;
	public AudioClip[] crashClips;
	private AudioSource windSound;
	public AudioClip windClip;
	private AudioSource brakeSound;
	public AudioClip brakeClip;
	private AudioSource skidSound;
	public AudioClip asphaltSkidClip;
	public AudioClip grassSkidClip;
	public AudioClip sandSkidClip;

	[Range(.25f, 1f)]public float minEngineSoundPitch = .75f;
	[Range(1.25f, 2f)]public float maxEngineSoundPitch = 1.75f;
	[Range(0f, 1f)]public float minEngineSoundVolume = .05f;
	[Range(0f, 1f)]public float maxEngineSoundVolume = .85f;

	[Range(0f, 1f)]public float maxGearShiftingSoundVolume = .3f;
	[Range(0f, 1f)]public float maxSkidSoundVolume = 1f;
	[Range(0f, 1f)]public float maxCrashSoundVolume = 1f;
	[Range(0f, 1f)]public float maxWindSoundVolume = .25f;
	[Range(0f, 1f)]public float maxBrakeSoundVolume = .2f;

	private GameObject allAudioSources;
	private GameObject allContactParticles;

	// Physic Materials.
	public PhysicMaterial asphaltPhysicsMaterial;
	public PhysicMaterial grassPhysicsMaterial;
	public PhysicMaterial sandPhysicsMaterial;
	public PhysicMaterial terrainPhysicsMaterial;

	// Use Terrain SplatMap For Various Ground Physics.
	public bool UseTerrainSplatMapForGroundPhysics = false;

	public int terrainSplatMapAsphaltIndex;
	public int terrainSplatMapGrassIndex;
	public int terrainSplatMapSandIndex;
	
	// Inputs.
	[HideInInspector]public float gasInput = 0f;
	[HideInInspector]public float brakeInput = 0f;
	[HideInInspector]public float steerInput = 0f;
	[HideInInspector]public float clutchInput = 0f;
	[HideInInspector]public float handbrakeInput = 0f;
	[HideInInspector]public float fuelInput = 1f;
	[HideInInspector]public float boostInput = 1f;

	private float engineRPM = 0f;		// Actual Engine RPM.
	private float wheelRPMToSpeed = 0f;		// Converted Wheel RPM To Speed.
	
	// UI DashBoard.
	public RCCDashboardInputs UIInputs;
	private RectTransform RPMNeedle;
	private RectTransform KMHNeedle;

	// NGUI Dashboard.
	public GameObject RPMNeedleNGUI;
	public GameObject KMHNeedleNGUI;

	private float RPMNeedleRotation = 0f;
	private float KMHNeedleRotation = 0f;
	private float smoothedNeedleRotation = 0f;
	
	// Smokes.
	public GroundMaterial _groundMaterial = GroundMaterial.Asphalt;
	public enum GroundMaterial{Asphalt, Grass, Sand} 
	
	public GameObject wheelSlipAsphalt;
	public GameObject wheelSlipSand;
	private List <ParticleSystem> _wheelSlipAsphalt = new List<ParticleSystem>();
	private List <ParticleSystem> _wheelSlipSand = new List<ParticleSystem>();

	// Exhaust Gasses.
	public ParticleSystem[] exhaustGas;
	
	public GameObject chassis;		// Script Will Simulate Chassis Movement Based On Vehicle Rigidbody Velocity.
	public float chassisVerticalLean = 4.0f;		// Chassis Vertical Lean Sensitivity.
	public float chassisHorizontalLean = 4.0f;		// Chassis Horizontal Lean Sensitivity.
	private float horizontalLean = 0.0f;
	private float verticalLean = 0.0f;
	
	// Lights.
	public Light[] headLights;
	public Light[] brakeLights;
	public Light[] reverseLights;
	public bool headLightsOn = false;
	private float brakeLightInput;

	// Damage.
	public bool useDamage = true;
	struct originalMeshVerts{public Vector3[] meshVerts;}
	public MeshFilter[] deformableMeshFilters;
	public float randomizeVertices = 1f;
	public float damageRadius = .5f;
	
	private float minimumVertDistanceForDamagedMesh = .002f;		// Comparing Original Vertex Positions Between Last Vertex Positions To Decide Mesh Is Repaired Or Not.
	
	private Vector3[] colliderVerts;
	private originalMeshVerts[] originalMeshData;
	[HideInInspector]public bool sleep = true;
	
	public float maximumDamage = .5f;		// Maximum Vert Distance For Limiting Damage. 0 Value Will Disable The Limit.
	private float minimumCollisionForce = 5f;
	public float damageMultiplier = 1f;
	
	public GameObject contactSparkle;
	public int maximumContactSparkle = 5;
	private List<ParticleSystem> contactSparkeList = new List<ParticleSystem>();
	public bool repairNow = false;
	
	private Vector3 localVector;
	private Quaternion rot = Quaternion.identity;

	//Steering Helper.
	[Range(0f, 1f)] public float steerHelper = .1f;
	private float oldRotation;

	//Driving Assistances.
	public bool ABS = true;
	public bool TCS = true;
	public bool ESP = true;
	public bool steeringHelper = true;
	
	public bool ABSAct = false;
	public bool TCSAct = false;
	public bool ESPAct = false;
	
	[Range(.05f, .5f)]public float ABSThreshold = .35f;
	[Range(.05f, .5f)]public float TCSThreshold = .25f;
	[Range(0f, 1f)]public float TCSStrength = 1f;
	[Range(.05f, .5f)]public float ESPThreshold = .25f;
	[Range(.1f, 1f)]public float ESPStrength = .5f;

	// Drift Variables
	internal float driftAngle = 0f;
	private bool driftingNow = false;
	public bool applyCounterSteering = false;

	//Steering Wheel.
	public GameObject steeringWheelGameObject;
	public Image steeringWheelTexture;	
	public float steeringWheelAngle = 0f;
	public float steeringWheelMaximumsteerAngle = 270f;
	public float steeringWheelResetPosSpeed = 10f;	
	public float steeringWheelCenterDeadZoneRadius = 5f;
	public float steeringWheelDefaultAlpha = .5f, steeringWheelActiveAlpha = 1f;
	public bool steeringWheelInteractable = true;
	
	private RectTransform steeringWheelRect;
	private CanvasGroup steeringWheelCanvasGroup;
	private float steeringWheelTempAngle, steeringWheelNewAngle;
	private bool steeringWheelPressed;
	private Vector2 steeringWheelCenter, steeringWheelTouchPos;

	private EventTrigger eventTrigger;
	
	void Awake() {

		if(!GetComponent<RCCAICarController>())
			AIController = false;
		
	}

	void Start (){

		rigid = GetComponent<Rigidbody>();
		rigid.maxAngularVelocity = 12f;
		Time.fixedDeltaTime = .02f;

		allWheelColliders = GetComponentsInChildren<WheelCollider>();
		WheelCollider anyWheel = GetComponentInChildren<WheelCollider>();
		anyWheel.ConfigureVehicleSubsteps(30f, 20, 20);
		_rotationValueExtra = new float[ExtraRearWheelsCollider.Length];
		defSteerAngle = steerAngle;

		allAudioSources = new GameObject("All Audio Sources");
		allAudioSources.transform.SetParent(transform);
		allAudioSources.transform.localPosition = Vector3.zero;
		allAudioSources.transform.localRotation = Quaternion.identity;

		allContactParticles = new GameObject("All Contact Particles");
		allContactParticles.transform.SetParent(transform);
		allContactParticles.transform.localPosition = Vector3.zero;
		allContactParticles.transform.localRotation = Quaternion.identity;

		if(dashBoard && GameObject.FindObjectOfType<RCCDashboardInputs>()){

			UIInputs = GameObject.FindObjectOfType<RCCDashboardInputs>();
			UIInputs.GetNeedles();

			if(_dashboardType == DashboardType.NGUIDashboard){
				RPMNeedleNGUI = UIInputs.RPMNeedleNGUI;
				KMHNeedleNGUI = UIInputs.KMHNeedleNGUI;
			}else{
				RPMNeedle = UIInputs.RPMNeedleUI;
				KMHNeedle = UIInputs.KMHNeedleUI;
			}
			 
		}else if(dashBoard){

			Debug.LogError("RCCDashboardInputs not found! Ensure your scene has UI or NGUI canvas with RCCDashboardInputs script. You can use ready to use prefabs in Prefabs folder.");
			dashBoard = false;

		}

		if(autoFindButtons && mobileController){

			RCCMobileButtons UIButtons = GameObject.FindObjectOfType<RCCMobileButtons>();

			if(_mobileControllerType == MobileGUIType.NGUIController){
				gasPedalNGUI = UIButtons.gasButton.GetComponent<RCCNGUIController>();
				brakePedalNGUI = UIButtons.brakeButton.GetComponent<RCCNGUIController>();
				leftArrowNGUI = UIButtons.leftButton.GetComponent<RCCNGUIController>();
				rightArrowNGUI = UIButtons.rightButton.GetComponent<RCCNGUIController>();
				if(UIButtons.handbrakeButton)
					handbrakeNGUI = UIButtons.handbrakeButton.GetComponent<RCCNGUIController>();
				if(UIButtons.boostButton)
					boostNGUI = UIButtons.boostButton.GetComponent<RCCNGUIController>();
			}else{
				gasPedalUI = UIButtons.gasButton.GetComponent<RCCUIController>();
				brakePedalUI = UIButtons.brakeButton.GetComponent<RCCUIController>();
				leftArrowUI = UIButtons.leftButton.GetComponent<RCCUIController>();
				rightArrowUI = UIButtons.rightButton.GetComponent<RCCUIController>();
				if(UIButtons.handbrakeButton)
					handbrakeUI = UIButtons.handbrakeButton.GetComponent<RCCUIController>();
				if(UIButtons.boostButton)
					boostUI = UIButtons.boostButton.GetComponent<RCCUIController>();
			}

			if(UIButtons.steeringWheel)
				steeringWheelTexture = UIButtons.steeringWheel.GetComponent<Image>();

		}

		SoundsInitialize();
		MobileGUI();
		SmokeInit();

		if(useDamage)
			DamageInit();

		if(runEngineAtAwake)
			KillOrStartEngine();
		
	}
	
	public void CreateWheelColliders (){
		
		List <Transform> allWheelTransforms = new List<Transform>();
		allWheelTransforms.Add(FrontLeftWheelTransform); allWheelTransforms.Add(FrontRightWheelTransform); allWheelTransforms.Add(RearLeftWheelTransform); allWheelTransforms.Add(RearRightWheelTransform);
		
		if(allWheelTransforms[0] == null){
			Debug.LogError("You haven't choose your Wheel Transforms. Please select all of your Wheel Transforms before creating Wheel Colliders. Script needs to know their positions, aye?");
			return;
		}
		
		transform.rotation = Quaternion.identity;
		
		GameObject WheelColliders = new GameObject("Wheel Colliders");
		WheelColliders.transform.SetParent(transform);
		WheelColliders.transform.localRotation = Quaternion.identity;
		WheelColliders.transform.localPosition = Vector3.zero;
		WheelColliders.transform.localScale = Vector3.one;
		
		foreach(Transform wheel in allWheelTransforms){
			
			GameObject wheelcollider = new GameObject(wheel.transform.name); 
			
			wheelcollider.transform.position = wheel.transform.position;
			wheelcollider.transform.rotation = transform.rotation;
			wheelcollider.transform.name = wheel.transform.name;
			wheelcollider.transform.SetParent(WheelColliders.transform);
			wheelcollider.transform.localScale = Vector3.one;
			wheelcollider.AddComponent<WheelCollider>();
			wheelcollider.GetComponent<WheelCollider>().radius = (wheel.GetComponent<MeshRenderer>().bounds.extents.y) / transform.localScale.y;

			wheelcollider.AddComponent<RCCWheelCollider>();
			
			JointSpring spring = wheelcollider.GetComponent<WheelCollider>().suspensionSpring;

			spring.spring = 35000f;
			spring.damper = 1500f;

			wheelcollider.GetComponent<WheelCollider>().suspensionSpring = spring;
			wheelcollider.GetComponent<WheelCollider>().suspensionDistance = .2f;
			wheelcollider.GetComponent<WheelCollider>().forceAppPointDistance = .15f;
			wheelcollider.GetComponent<WheelCollider>().mass = 125f;
			wheelcollider.GetComponent<WheelCollider>().wheelDampingRate = 1f;
			
			sidewaysFriction = wheelcollider.GetComponent<WheelCollider>().sidewaysFriction;
			forwardFriction = wheelcollider.GetComponent<WheelCollider>().forwardFriction;

			forwardFriction.extremumSlip = .4f;
			forwardFriction.extremumValue = 1;
			forwardFriction.asymptoteSlip = .8f;
			forwardFriction.asymptoteValue = .75f;
			forwardFriction.stiffness = 1f;

			sidewaysFriction.extremumSlip = .25f;
			sidewaysFriction.extremumValue = 1;
			sidewaysFriction.asymptoteSlip = .5f;
			sidewaysFriction.asymptoteValue = .75f;
			sidewaysFriction.stiffness = 1f;

			wheelcollider.GetComponent<WheelCollider>().sidewaysFriction = sidewaysFriction;
			wheelcollider.GetComponent<WheelCollider>().forwardFriction = forwardFriction;

		}
		
		WheelCollider[] allWheelColliders = new WheelCollider[allWheelTransforms.Count];
		allWheelColliders = GetComponentsInChildren<WheelCollider>();
		
		FrontLeftWheelCollider = allWheelColliders[0];
		FrontRightWheelCollider = allWheelColliders[1];
		RearLeftWheelCollider = allWheelColliders[2];
		RearRightWheelCollider = allWheelColliders[3];
		
	}
	
	public void SoundsInitialize (){

		engineSoundOn = RCCCreateAudioSource.NewAudioSource(gameObject, "Engine Sound On AudioSource", 5, 100, 0, engineClipOn, true, true, false);
		engineSoundOff = RCCCreateAudioSource.NewAudioSource(gameObject, "Engine Sound Off AudioSource", 5, 100, 0, engineClipOff, true, true, false);
		windSound = RCCCreateAudioSource.NewAudioSource(gameObject, "Wind Sound AudioSource", 5, 10, 0, windClip, true, true, false);
		brakeSound = RCCCreateAudioSource.NewAudioSource(gameObject, "Brake Sound AudioSource", 5, 10, 0, brakeClip, true, true, false);
		skidSound = RCCCreateAudioSource.NewAudioSource(gameObject, "Skid Sound AudioSource", 5, 50, 0, asphaltSkidClip, true, false, false);
		
	}
	
	public void KillOrStartEngine (){
		
		if(engineRunning && !engineStarting){
			engineRunning = false;
		}else if(!engineStarting){
			StartCoroutine("StartEngine");
		}
		
	}
	
	public IEnumerator StartEngine (){

		engineRunning = false;
		engineStarting = true;
		if(!engineRunning)
			engineStartSound = RCCCreateAudioSource.NewAudioSource(gameObject, "Engine Start AudioSource", 5, 10, 1, engineStartClip, false, true, true);
		yield return new WaitForSeconds(1f);
		engineRunning = true;
		yield return new WaitForSeconds(1f);
		engineStarting = false;

	}
	
	public void SmokeInit (){

		if(wheelSlipAsphalt){
		
			for(int i = 0; i < allWheelColliders.Length; i++){
				GameObject ps = (GameObject)Instantiate(wheelSlipAsphalt, transform.position, transform.rotation) as GameObject;
				_wheelSlipAsphalt.Add(ps.GetComponent<ParticleSystem>());
				ps.GetComponent<ParticleSystem>().enableEmission = false;
				ps.transform.SetParent(allWheelColliders[i].transform);
				ps.transform.localPosition = Vector3.zero;
			}

		}

		if(wheelSlipSand){

			for(int i = 0; i < allWheelColliders.Length; i++){
				GameObject ps = (GameObject)Instantiate(wheelSlipSand, transform.position, transform.rotation) as GameObject;
				_wheelSlipSand.Add(ps.GetComponent<ParticleSystem>());
				ps.GetComponent<ParticleSystem>().enableEmission = false;
				ps.transform.SetParent(allWheelColliders[i].transform);
				ps.transform.localPosition = Vector3.zero;
			}

		}

	}

	public void DamageInit (){

		if (deformableMeshFilters.Length == 0){

			MeshFilter[] allMeshFilters = GetComponentsInChildren<MeshFilter>();
			List <MeshFilter> properMeshFilters = new List<MeshFilter>();

			foreach(MeshFilter mf in allMeshFilters){
				if(mf.gameObject != FrontLeftWheelTransform.gameObject && mf.gameObject != FrontRightWheelTransform.gameObject && mf.gameObject != RearLeftWheelTransform.gameObject && mf.gameObject != RearRightWheelTransform.gameObject)
					properMeshFilters.Add(mf);
			}

			deformableMeshFilters = properMeshFilters.ToArray();

		}
		
		LoadOriginalMeshData();
		
		if(contactSparkle){
			
			for(int i = 0; i < maximumContactSparkle; i++){
				GameObject sparks = (GameObject)Instantiate(contactSparkle, transform.position, Quaternion.identity) as GameObject;
				sparks.transform.SetParent(allContactParticles.transform);
				contactSparkeList.Add(sparks.GetComponent<ParticleSystem>());
				sparks.GetComponent<ParticleSystem>().enableEmission = false;
			}
			
		}

	}

	void SteeringWheelInit(){

		steeringWheelGameObject = steeringWheelTexture.gameObject;
		steeringWheelRect = steeringWheelTexture.rectTransform;
		steeringWheelCanvasGroup = steeringWheelTexture.GetComponent<CanvasGroup> ();
		steeringWheelCenter = steeringWheelRect.position;
		steeringWheelCanvasGroup.alpha = steeringWheelDefaultAlpha;
		
		SteeringWheelEventsInit ();

	}

	void LoadOriginalMeshData(){

		originalMeshData = new originalMeshVerts[deformableMeshFilters.Length];

		for (int i = 0; i < deformableMeshFilters.Length; i++){
			originalMeshData[i].meshVerts = deformableMeshFilters[i].mesh.vertices;
		}

	}

	void Damage(){

		if (!sleep && repairNow){
			
			int k;
			sleep = true;

			for(k = 0; k < deformableMeshFilters.Length; k++){

				Vector3[] vertices = deformableMeshFilters[k].mesh.vertices;

				if(originalMeshData==null)
					LoadOriginalMeshData();

				for (int i = 0; i < vertices.Length; i++){

					vertices[i] += (originalMeshData[k].meshVerts[i] - vertices[i]) * (Time.deltaTime * 2f);
					if((originalMeshData[k].meshVerts[i] - vertices[i]).magnitude >= minimumVertDistanceForDamagedMesh)
						sleep = false;

				}

				deformableMeshFilters[k].mesh.vertices=vertices;
				deformableMeshFilters[k].mesh.RecalculateNormals();
				deformableMeshFilters[k].mesh.RecalculateBounds();

			}
			
			if(sleep)
				repairNow = false;
			
		}

	}

	void DeformMesh(Mesh mesh, Vector3[] originalMesh, Collision collision, float cos, Transform meshTransform, Quaternion rot){
		
		Vector3[] vertices = mesh.vertices;
		
		foreach (ContactPoint contact in collision.contacts){
			
			Vector3 point = meshTransform.InverseTransformPoint(contact.point);
			 
			for (int i = 0; i < vertices.Length; i++){

				if ((point - vertices[i]).magnitude < damageRadius){
					vertices[i] += rot * ((localVector * (damageRadius - (point - vertices[i]).magnitude) / damageRadius) * cos + (UnityEngine.Random.onUnitSphere * (randomizeVertices / 500f)));
					if (maximumDamage > 0 && ((vertices[i] - originalMesh[i]).magnitude) > maximumDamage){
						vertices[i] = originalMesh[i] + (vertices[i] - originalMesh[i]).normalized * (maximumDamage);
					}
				}
			}
			
		}
		
		mesh.vertices = vertices;
		mesh.RecalculateNormals();
		mesh.RecalculateBounds();
		
	}

	void CollisionParticles(Vector3 contactPoint){
		
		for(int i = 0; i < contactSparkeList.Count; i++){
			if(contactSparkeList[i].isPlaying)
				return;
			contactSparkeList[i].transform.position = contactPoint;
			contactSparkeList[i].enableEmission = true;
			contactSparkeList[i].Play();
		}
		
	}
	
	public void MobileGUI (){

		if(mobileController){
			if(_mobileControllerType == MobileGUIType.NGUIController){
				defbrakePedalPosition = brakePedalNGUI.transform.position;
			}else{
				defbrakePedalPosition = brakePedalUI.transform.position;
			}
		}
		
	}
	
	void Update (){

		//Enables inputs for controlling vehicle.
		if(canControl){
			Lights();
			ResetCar();
			if(!AIController && !mobileController)
				KeyboardControlling();
			if(steeringWheelControl && !steeringWheelRect && steeringWheelTexture)
				SteeringWheelInit();
		}else if(!AIController){
			gasInput = 0f;
			brakeInput = 0f;
			boostInput = 1f;
			handbrakeInput = 1f;
		}

		GearBox();

		if(!sleepingRigid){

			WheelAlign(FrontLeftWheelCollider, FrontLeftWheelTransform, _rotationValueFL);
			WheelAlign(FrontRightWheelCollider, FrontRightWheelTransform, _rotationValueFR);
			WheelAlign(RearLeftWheelCollider, RearLeftWheelTransform, _rotationValueRL);
			WheelAlign(RearRightWheelCollider, RearRightWheelTransform, _rotationValueRR);

			_rotationValueFL = WheelRotation(FrontLeftWheelCollider, _rotationValueFL); 
			_rotationValueFR = WheelRotation(FrontRightWheelCollider, _rotationValueFR); 
			_rotationValueRL = WheelRotation(RearLeftWheelCollider, _rotationValueRL); 
			_rotationValueRR = WheelRotation(RearRightWheelCollider, _rotationValueRR);

			if(ExtraRearWheelsCollider.Length > 0){
				for(int i = 0; i < ExtraRearWheelsCollider.Length; i ++){
					WheelAlign(ExtraRearWheelsCollider[i], ExtraRearWheelsTransform[i], _rotationValueExtra[i]);
					_rotationValueExtra[i] = WheelRotation(ExtraRearWheelsCollider[i], _rotationValueExtra[i]); 
				}
			}

			for(int i = 0; i < allWheelColliders.Length; i++){
				WheelCamber(allWheelColliders[i]);
			}

		}

		GroundPhysicsMaterial();
		Sounds();

		if(useDamage)
			Damage();

		if(chassis)
			Chassis();

		if(dashBoard && canControl)
			Dashboard();
		
	}
	
	void FixedUpdate (){

		if(canControl){
			if(mobileController && !AIController){
				if(_mobileControllerType == MobileGUIType.NGUIController)
					NGUIControlling();
				if(_mobileControllerType == MobileGUIType.UIController)
					UIControlling();
				MobileSteeringInputs();
			}
			SteeringWheelControlling();
		}

		Engine();
		Braking();
		AntiRollBars();
		DownForce();
		DriftVariables();
		SmokeWeedEveryday(_groundMaterial);
		ApplySteering(FrontLeftWheelCollider);
		ApplySteering(FrontRightWheelCollider);

		if(steeringHelper)
			SteerHelper();

		if(ESP){
			if(transform.TransformDirection(rigid.angularVelocity).y > 0){
				ESPCheck(FrontLeftWheelCollider, FrontRightWheelCollider, RearLeftWheelCollider);
				ESPCheck(RearLeftWheelCollider, RearRightWheelCollider, FrontLeftWheelCollider);
			}
			if(transform.TransformDirection(rigid.angularVelocity).y < 0){
				ESPCheck(FrontLeftWheelCollider, FrontRightWheelCollider, RearRightWheelCollider);
				ESPCheck(RearLeftWheelCollider, RearRightWheelCollider, FrontRightWheelCollider);
			}
		}
		
	}
	
	public void Engine (){
		
		//Speed.
		speed = rigid.velocity.magnitude * 3.6f;

		//Acceleration Calculation.
		acceleration = 0f;
		acceleration = (transform.InverseTransformDirection(rigid.velocity).z - lastVelocity) / Time.fixedDeltaTime;
		lastVelocity = transform.InverseTransformDirection(rigid.velocity).z;
		
		//Drag Limit Depends On Vehicle Acceleration.
		rigid.drag = Mathf.Clamp((acceleration / 50f), .05f, .1f);

		//Angular Drag Limit Depends On Vehicle Speed.
		rigid.angularDrag = Mathf.Clamp((speed / maxspeed), .05f, .25f);

		//Steer Limit.
		steerAngle = Mathf.Lerp(defSteerAngle, highspeedsteerAngle, (speed / highspeedsteerAngleAtspeed));

		//Driver SteeringWheel Transform.
		if(SteeringWheel)
			SteeringWheel.transform.rotation = transform.rotation * Quaternion.Euler(20, 0, (FrontLeftWheelCollider.steerAngle) * -6);

		if(rigid.velocity.magnitude < .01f && Mathf.Abs(steerInput) < .01f && Mathf.Abs(gasInput) < .01f && Mathf.Abs(rigid.angularVelocity.x) < .01f )
			sleepingRigid = true;
		else
			sleepingRigid = false;

		WheelHit hit;
		float rpm = 0f;

		if(_wheelTypeChoise == WheelType.RWD || _wheelTypeChoise == WheelType.AWD || _wheelTypeChoise == WheelType.DRIFT){
			RearLeftWheelCollider.GetGroundHit(out hit);
			wheelRPMToSpeed = ((Mathf.Abs((RearLeftWheelCollider.rpm * RearLeftWheelCollider.radius) + (RearRightWheelCollider.rpm * RearRightWheelCollider.radius)) / 2f) / 2.625f);
		}

		if(_wheelTypeChoise == WheelType.FWD){
			FrontLeftWheelCollider.GetGroundHit(out hit);
			wheelRPMToSpeed = ((Mathf.Abs((FrontLeftWheelCollider.rpm * FrontLeftWheelCollider.radius) + (FrontRightWheelCollider.rpm * FrontRightWheelCollider.radius)) / 2f) / 2.625f);
		}

		if(!reverseGear){
			rpm = Mathf.Clamp(
				Mathf.Lerp(
				minEngineRPM, maxEngineRPM, (wheelRPMToSpeed - (currentGear != 0 ? gearSpeed[currentGear - 1] : 0)) / (gearSpeed[currentGear] * 1f))
				* (1 - clutchInput) + ((clutchInput * gasInput) * maxEngineRPM), minEngineRPM, maxEngineRPM);
		}else{
			if(automaticGear){
				rpm = Mathf.Clamp(
					Mathf.Lerp(
					minEngineRPM, maxEngineRPM, (wheelRPMToSpeed) / (gearSpeed[currentGear] * 2f))
					* (1 - clutchInput) + ((clutchInput * brakeInput) * maxEngineRPM), minEngineRPM, maxEngineRPM);
			}else{
				rpm = Mathf.Clamp(
					Mathf.Lerp(
					minEngineRPM, maxEngineRPM, (wheelRPMToSpeed) / (gearSpeed[currentGear] * 2f))
					* (1 - clutchInput) + ((clutchInput * gasInput) * maxEngineRPM), minEngineRPM, maxEngineRPM);
			}
		}

		engineRPM = Mathf.Lerp(engineRPM, (rpm + UnityEngine.Random.Range(-50f, 50f)) * fuelInput, Time.deltaTime * 2f);

		if(engineRPM < (minEngineRPM / 2f) && !engineStarting){
			if(canEngineStall)
				engineRunning = false;
		}

		if(!engineRunning)
			fuelInput = 0;
		else
			fuelInput = 1;
		
		//Auto Reverse Bool.
		if(autoReverse){
			canGoReverseNow = true;
		}else{
			if(brakeInput < .1f && speed < 5)
				canGoReverseNow = true;
			else if(brakeInput > 0 && transform.InverseTransformDirection(rigid.velocity).z > 1f)
				canGoReverseNow = false;
		}

		for(int i = 0; i < allWheelColliders.Length; i++){
			allWheelColliders[i].wheelDampingRate = Mathf.Lerp(2f, 0f, gasInput);
		}
		
		#region Wheel Type Motor Torque.

		//Applying WheelCollider Motor Torques Depends On Wheel Type Choice.
		switch(_wheelTypeChoise){
			
		case WheelType.FWD:
			ApplyMotorTorque(FrontLeftWheelCollider, engineTorque);
			ApplyMotorTorque(FrontRightWheelCollider, engineTorque);
			break;
		case WheelType.RWD:
			ApplyMotorTorque(RearLeftWheelCollider, engineTorque);
			ApplyMotorTorque(RearRightWheelCollider, engineTorque);
			break;
		case WheelType.AWD:
			ApplyMotorTorque(FrontLeftWheelCollider, engineTorque / 2f);
			ApplyMotorTorque(FrontRightWheelCollider, engineTorque / 2f);
			ApplyMotorTorque(RearLeftWheelCollider, engineTorque / 2f);
			ApplyMotorTorque(RearRightWheelCollider, engineTorque / 2f);
			break;
		case WheelType.DRIFT:
			ApplyMotorTorque(FrontLeftWheelCollider, (engineTorque * 30) / 100f);
			ApplyMotorTorque(FrontRightWheelCollider, (engineTorque * 30) / 100f);
			ApplyMotorTorque(RearLeftWheelCollider, (engineTorque * 70) / 100f);
			ApplyMotorTorque(RearRightWheelCollider, (engineTorque * 70) / 100f);
			break;

		}

		if(ExtraRearWheelsCollider.Length > 0 && applyEngineTorqueToExtraRearWheelColliders){

			for(int i = 0; i < ExtraRearWheelsCollider.Length; i++){
				ApplyMotorTorque(ExtraRearWheelsCollider[i], engineTorque);
			}

		}
		
		#endregion Wheel Type
		
	}

	public void Sounds(){

		windSound.volume = Mathf.Lerp (0f, maxWindSoundVolume, speed / maxspeed);
		windSound.pitch = UnityEngine.Random.Range(.9f, 1.1f);
		
		if(!reverseGear)
			brakeSound.volume = Mathf.Lerp (0f, maxBrakeSoundVolume, Mathf.Clamp01((FrontLeftWheelCollider.brakeTorque + FrontRightWheelCollider.brakeTorque) / (brake * 2f)) * Mathf.Lerp(0f, 1f, FrontLeftWheelCollider.rpm / 50f));
		else
			brakeSound.volume = 0f;

	}

	public void ApplyMotorTorque(WheelCollider wc, float torque){

		if(TCS){

			WheelHit hit;
			wc.GetGroundHit(out hit);

			if(Mathf.Abs(wc.rpm) >= 100){
				if(hit.forwardSlip > .25f){
					TCSAct = true;
					torque -= Mathf.Clamp(torque * (hit.forwardSlip) * TCSStrength, 0f, engineTorque);
				}else{
					TCSAct = false;
					torque += Mathf.Clamp(torque * (hit.forwardSlip) * TCSStrength, -engineTorque, 0f);
				}
			}else{
				TCSAct = false;
			}
			
		}

		if(OverTorque())
			torque = 0;

		if(automaticGear){

			if(!reverseGear)
				wc.motorTorque = (torque * (1 - clutchInput)) * (Mathf.Clamp((gasInput * fuelInput), 0f, 1f) * boostInput) * engineTorqueCurve[currentGear].Evaluate(wheelRPMToSpeed);
			else
				wc.motorTorque = (-torque * (1 - clutchInput)) * (Mathf.Clamp((brakeInput * fuelInput), 0f, 1f) * boostInput) * engineTorqueCurve[currentGear].Evaluate(wheelRPMToSpeed);

		}else{

			if(!reverseGear)
				wc.motorTorque = (torque * (1 - clutchInput)) * (Mathf.Clamp((gasInput * fuelInput), 0f, 1f) * boostInput) * engineTorqueCurve[currentGear].Evaluate(wheelRPMToSpeed);
			else
				wc.motorTorque = (-torque * (1 - clutchInput)) * (Mathf.Clamp((gasInput * fuelInput), 0f, 1f) * boostInput) * engineTorqueCurve[currentGear].Evaluate(wheelRPMToSpeed);

		}

		ApplyEngineSound(wc.motorTorque);
		
	}

	public void ESPCheck(WheelCollider slippingLeftWheel, WheelCollider slippingRightWheel, WheelCollider correspondingWheel){

		WheelHit leftHit;
		slippingLeftWheel.GetGroundHit(out leftHit);

		WheelHit rightHit;
		slippingRightWheel.GetGroundHit(out rightHit);

		float totalSlip = Mathf.Abs(leftHit.sidewaysSlip) + Mathf.Abs(rightHit.sidewaysSlip);

		if(totalSlip > ESPThreshold){
			ESPAct = true;
			ApplyBrakeTorque(correspondingWheel, (brake * ESPStrength) * totalSlip);

		}else{
			ESPAct = false;
		}

	}

	public void ApplyBrakeTorque(WheelCollider wc, float brake){

		if(ABS && handbrakeInput <= .1f){

			WheelHit hit;
			wc.GetGroundHit(out hit);

			if((Mathf.Abs(hit.forwardSlip) * brakeInput) >= ABSThreshold){
				ABSAct = true;
				brake = 0;
			}else{
				ABSAct = false;
			}

		}

		wc.brakeTorque = brake;

	}

	public void ApplySteering(WheelCollider wc){

		if(!applyCounterSteering)
			wc.steerAngle = Mathf.Clamp((steerAngle * steerInput), -steerAngle, steerAngle);
		else
			wc.steerAngle = Mathf.Clamp((steerAngle * (steerInput + driftAngle)), -steerAngle, steerAngle);

	}

	public void ApplyEngineSound(float input){
		
		//Engine Audio Volume.
		if(engineSoundOn){

			if(automaticGear){

				if(!reverseGear)
					engineSoundOn.volume = Mathf.Lerp (engineSoundOn.volume, Mathf.Clamp (gasInput, minEngineSoundVolume * fuelInput, maxEngineSoundVolume), Time.deltaTime * 50f);
				else
					engineSoundOn.volume = Mathf.Lerp (engineSoundOn.volume, Mathf.Clamp (brakeInput, minEngineSoundVolume * fuelInput, maxEngineSoundVolume), Time.deltaTime * 50f);

			}else{

				engineSoundOn.volume = Mathf.Lerp (engineSoundOn.volume, Mathf.Clamp (gasInput, minEngineSoundVolume * fuelInput, maxEngineSoundVolume), Time.deltaTime * 50f);

			}

			if(engineRunning)
				engineSoundOn.pitch = Mathf.Lerp ( engineSoundOn.pitch, Mathf.Lerp (minEngineSoundPitch * fuelInput, maxEngineSoundPitch, (engineRPM) / (maxEngineRPM)), Time.deltaTime * 50f);
			else
				engineSoundOn.pitch = Mathf.Lerp ( engineSoundOn.pitch, 0, Time.deltaTime * 50f);
			
		}
		
		if(engineSoundOff){

			if(automaticGear){

				if(!reverseGear)
					engineSoundOff.volume = Mathf.Lerp (engineSoundOff.volume, Mathf.Clamp (((1 + (-gasInput)) * fuelInput), minEngineSoundVolume * fuelInput, .5f), Time.deltaTime * 50f);
				else
					engineSoundOff.volume = Mathf.Lerp (engineSoundOff.volume, Mathf.Clamp (((1 + (-brakeInput)) * fuelInput), minEngineSoundVolume * fuelInput, .5f), Time.deltaTime * 50f);

			}else{

				engineSoundOff.volume = Mathf.Lerp (engineSoundOff.volume, Mathf.Clamp (((1 + (gasInput)) * fuelInput), minEngineSoundVolume * fuelInput, .5f), Time.deltaTime * 50f);

			}

			if(engineRunning)
				engineSoundOff.pitch = Mathf.Lerp ( engineSoundOff.pitch, Mathf.Lerp (minEngineSoundPitch * fuelInput, maxEngineSoundPitch, (engineRPM) / (maxEngineRPM)), Time.deltaTime * 50f);
			else
				engineSoundOff.pitch = Mathf.Lerp ( engineSoundOff.pitch, 0, Time.deltaTime * 50f);

		}

	}
	
	public void Braking (){

		//Handbrake
		if(handbrakeInput > .1f){
			
			ApplyBrakeTorque(RearLeftWheelCollider, (brake * 1.5f) * handbrakeInput);
			ApplyBrakeTorque(RearRightWheelCollider, (brake * 1.5f) * handbrakeInput);
			
		}else{
			
			// Braking.

			if(automaticGear){

				if(brakeInput > .1f && !reverseGear){
					ApplyBrakeTorque(FrontLeftWheelCollider, brake * (brakeInput));
					ApplyBrakeTorque(FrontRightWheelCollider, brake * (brakeInput));
					ApplyBrakeTorque(RearLeftWheelCollider, brake * brakeInput / 2f);
					ApplyBrakeTorque(RearRightWheelCollider, brake * brakeInput / 2f);
				}else if(brakeInput > .1f && reverseGear){
					ApplyBrakeTorque(FrontLeftWheelCollider, 0f);
					ApplyBrakeTorque(FrontRightWheelCollider, 0f);
					ApplyBrakeTorque(RearLeftWheelCollider, 0f);
					ApplyBrakeTorque(RearRightWheelCollider, 0f);
				}else if(brakeInput < .1f){
					ApplyBrakeTorque(FrontLeftWheelCollider, 0f);
					ApplyBrakeTorque(FrontRightWheelCollider, 0f);
					ApplyBrakeTorque(RearLeftWheelCollider, 0f);
					ApplyBrakeTorque(RearRightWheelCollider, 0f);
				}

			}else{

				if(brakeInput > .1f && !reverseGear){
					ApplyBrakeTorque(FrontLeftWheelCollider, brake * (brakeInput));
					ApplyBrakeTorque(FrontRightWheelCollider, brake * (brakeInput));
					ApplyBrakeTorque(RearLeftWheelCollider, brake * brakeInput / 2f);
					ApplyBrakeTorque(RearRightWheelCollider, brake * brakeInput / 2f);
				}else if(brakeInput > .1f && reverseGear){
					ApplyBrakeTorque(FrontLeftWheelCollider, brake * (brakeInput));
					ApplyBrakeTorque(FrontRightWheelCollider, brake * (brakeInput));
					ApplyBrakeTorque(RearLeftWheelCollider, brake * brakeInput);
					ApplyBrakeTorque(RearRightWheelCollider, brake * brakeInput);
				}else if(brakeInput < .1f){
					ApplyBrakeTorque(FrontLeftWheelCollider, 0f);
					ApplyBrakeTorque(FrontRightWheelCollider, 0f);
					ApplyBrakeTorque(RearLeftWheelCollider, 0f);
					ApplyBrakeTorque(RearRightWheelCollider, 0f);
				}

			}
			
		}
		
	}
	
	public void AntiRollBars (){

		WheelHit FrontWheelHit;
		
		float travelFL = 1.0f;
		float travelFR = 1.0f;
		
		bool groundedFL= FrontLeftWheelCollider.GetGroundHit(out FrontWheelHit);
		
		if (groundedFL)
			travelFL = (-FrontLeftWheelCollider.transform.InverseTransformPoint(FrontWheelHit.point).y - FrontLeftWheelCollider.radius) / FrontLeftWheelCollider.suspensionDistance;
		
		bool groundedFR= FrontRightWheelCollider.GetGroundHit(out FrontWheelHit);
		
		if (groundedFR)
			travelFR = (-FrontRightWheelCollider.transform.InverseTransformPoint(FrontWheelHit.point).y - FrontRightWheelCollider.radius) / FrontRightWheelCollider.suspensionDistance;
		
		float antiRollForceFront= (travelFL - travelFR) * antiRoll;
		
		if (groundedFL)
			rigid.AddForceAtPosition(FrontLeftWheelCollider.transform.up * -antiRollForceFront, FrontLeftWheelCollider.transform.position); 
		if (groundedFR)
			rigid.AddForceAtPosition(FrontRightWheelCollider.transform.up * antiRollForceFront, FrontRightWheelCollider.transform.position); 
		
		WheelHit RearWheelHit;
		
		float travelRL = 1.0f;
		float travelRR = 1.0f;
		
		bool groundedRL= RearLeftWheelCollider.GetGroundHit(out RearWheelHit);
		
		if (groundedRL)
			travelRL = (-RearLeftWheelCollider.transform.InverseTransformPoint(RearWheelHit.point).y - RearLeftWheelCollider.radius) / RearLeftWheelCollider.suspensionDistance;
		
		bool groundedRR= RearRightWheelCollider.GetGroundHit(out RearWheelHit);
		
		if (groundedRR)
			travelRR = (-RearRightWheelCollider.transform.InverseTransformPoint(RearWheelHit.point).y - RearRightWheelCollider.radius) / RearRightWheelCollider.suspensionDistance;
		
		float antiRollForceRear= (travelRL - travelRR) * antiRoll;
		
		if (groundedRL)
			rigid.AddForceAtPosition(RearLeftWheelCollider.transform.up * -antiRollForceRear, RearLeftWheelCollider.transform.position); 
		if (groundedRR)
			rigid.AddForceAtPosition(RearRightWheelCollider.transform.up * antiRollForceRear, RearRightWheelCollider.transform.position);

		if (groundedRR && groundedRL && AIController)
			rigid.AddRelativeTorque((Vector3.up * (steerInput * gasInput)) * 2000f);

		if(_wheelTypeChoise == WheelType.DRIFT && groundedRR && groundedRL)
			rigid.AddRelativeTorque((Vector3.up * (steerInput * gasInput)) * 5000f);

	}

	public void DownForce(){
		rigid.AddForce(-transform.up * (downForce * rigid.velocity.magnitude));
	}

	public void SteerHelper(){

		for (int i = 0; i < allWheelColliders.Length; i++){
			WheelHit hit;
			allWheelColliders[i].GetGroundHit(out hit);
			if (hit.normal == Vector3.zero)
				return;
		}

		if (Mathf.Abs(oldRotation - transform.eulerAngles.y) < 10f){
			float turnadjust = (transform.eulerAngles.y - oldRotation) * steerHelper;
			Quaternion velRotation = Quaternion.AngleAxis(turnadjust, Vector3.up);
			rigid.velocity = velRotation * rigid.velocity;
		}

		oldRotation = transform.eulerAngles.y;

	}
	
	public void MobileSteeringInputs (){
		
		//Accelerometer Inputs.
		if(useAccelerometerForSteer){
			
			steerInput = Input.acceleration.x * gyroTiltMultiplier;

		//TouchScreen Inputs.
		}else if(steeringWheelControl){

			steerInput = GetSteeringWheelInput();
		
		}
		
	}
	
	public void SteeringWheelControlling (){

		if(!steeringWheelCanvasGroup || !steeringWheelRect || !steeringWheelControl){
			if(steeringWheelGameObject)
				steeringWheelGameObject.SetActive(false);
			return;
		}

		if(!steeringWheelGameObject.activeSelf)
			steeringWheelGameObject.SetActive(true);

		if(steeringWheelPressed){

			if(steeringWheelInteractable){

				steeringWheelCanvasGroup.alpha = steeringWheelActiveAlpha;
				steeringWheelNewAngle = Vector2.Angle(Vector2.up, steeringWheelTouchPos - steeringWheelCenter);

				if(Vector2.Distance( steeringWheelTouchPos, steeringWheelCenter ) > steeringWheelCenterDeadZoneRadius){

					if(steeringWheelTouchPos.x > steeringWheelCenter.x)
						steeringWheelAngle += steeringWheelNewAngle - steeringWheelTempAngle;
					else
						steeringWheelAngle -= steeringWheelNewAngle - steeringWheelTempAngle;

				}

				if(steeringWheelAngle > steeringWheelMaximumsteerAngle)
					steeringWheelAngle = steeringWheelMaximumsteerAngle;
				else if(steeringWheelAngle < -steeringWheelMaximumsteerAngle)
					steeringWheelAngle = -steeringWheelMaximumsteerAngle;
				
				steeringWheelTempAngle = steeringWheelNewAngle;

			}

		}else{

			steeringWheelCanvasGroup.alpha = steeringWheelDefaultAlpha;

			if(!Mathf.Approximately(0f, steeringWheelAngle)){

				float deltaAngle = steeringWheelResetPosSpeed;
				
				if(Mathf.Abs(deltaAngle) > Mathf.Abs(steeringWheelAngle)){
					steeringWheelAngle = 0f;
					return;
				}
				
				if(steeringWheelAngle > 0f)
					steeringWheelAngle -= deltaAngle;
				else
					steeringWheelAngle += deltaAngle;

			}

		}

		steeringWheelRect.eulerAngles = new Vector3 (0, 0, -steeringWheelAngle);
		
	}
	#region PlayerInputs
	public void KeyboardControlling (){

		//Start Or Stop The Engine.
		if(Input.GetKeyDown(KeyCode.I))
			KillOrStartEngine();

		//Motor Input.
		if(!changingGear){
			gasInput = Mathf.Lerp(gasInput, Mathf.Clamp01(Input.GetAxis("Vertical")), Time.deltaTime * 10f);
		}else{
			gasInput = Mathf.Lerp(gasInput, 0, Time.deltaTime * 10f);
		}

		brakeInput = Mathf.Lerp(brakeInput, -Mathf.Clamp(Input.GetAxis("Vertical"), -1f, 0f), Time.deltaTime * 10f);
		handbrakeInput = Input.GetAxis("Jump");

		//Steering Input.
		if(Mathf.Abs(Input.GetAxis("Horizontal")) > .05f)
			steerInput = Mathf.Lerp (steerInput, Input.GetAxis("Horizontal"), Time.deltaTime * 20f);
		else
			steerInput = Mathf.Lerp (steerInput, Input.GetAxis("Horizontal"), Time.deltaTime * 20f);
		
		//Boost Input.
		if(Input.GetButton("Fire2"))
			boostInput = 2.5f;
		else
			boostInput = 1f;

	}
	
	public void NGUIControlling (){
		
		//Motor Input.
		if(!changingGear)
			gasInput = gasPedalNGUI.input;
		else
			gasInput = 0;

		//Brake Input.
		brakeInput = brakePedalNGUI.input;
		
		//Steer Input.
		if(!useAccelerometerForSteer && !steeringWheelControl)
			steerInput = rightArrowNGUI.input + (-leftArrowNGUI.input);
		
		//Handbrake Input.
		if(handbrakeNGUI.input > .1f)
			handbrakeInput = 1;
		else
			handbrakeInput = 0;
		
		//Boost Input.
		if(boostNGUI)
			boostInput = Mathf.Clamp(boostNGUI.input * 2f, 1f, 2.5f);
		
	}

	public void UIControlling (){
		
		//Motor Input.
		if(!changingGear)
			gasInput = gasPedalUI.input;
		else
			gasInput = 0;

		//Brake Input.
		brakeInput = brakePedalUI.input;
		
		//Steer Input.
		if(!useAccelerometerForSteer && !steeringWheelControl)
			steerInput = rightArrowUI.input + (-leftArrowUI.input);
		
		//Handbrake Input.
		if(handbrakeUI.input > .1f)
			handbrakeInput = 1;
		else if(handbrakeUI.input < .9f)
			handbrakeInput = 0;

		//Boost Input.
		if(boostUI)
			boostInput = Mathf.Clamp(boostUI.input * 2f, 1f, 2.5f);
		
	}
	#endregion
	public void GearBox (){

		if(speed <= gearSpeed[0]){

			if(handbrakeInput < .1f){

				if(!reverseGear && automaticGear)
					clutchInput = Mathf.Lerp(clutchInput, (Mathf.Lerp(1f, (Mathf.Lerp(.25f, 0f, wheelRPMToSpeed / gearSpeed[0])), gasInput)), Time.deltaTime * 50f);
				else if(automaticGear)
					clutchInput = Mathf.Lerp(clutchInput, (Mathf.Lerp(1f, (Mathf.Lerp(.25f, 0f, wheelRPMToSpeed / gearSpeed[0])), brakeInput)), Time.deltaTime * 50f);
				else if(!automaticGear && !reverseGear)
					clutchInput = Mathf.Lerp(clutchInput, (Mathf.Lerp(1f, (Mathf.Lerp(.25f, 0f, wheelRPMToSpeed / gearSpeed[0])), gasInput)), Time.deltaTime * 50f);
				else
					clutchInput = Mathf.Lerp(clutchInput, (Mathf.Lerp(1f, (Mathf.Lerp(.25f, 0f, wheelRPMToSpeed / gearSpeed[0])), gasInput)), Time.deltaTime * 50f);

			}else{

				clutchInput = Mathf.Lerp(clutchInput, 1, Time.deltaTime * 10f);

			}

		}else{
			if(changingGear)
				clutchInput = Mathf.Lerp(clutchInput, 1, Time.deltaTime * 10f);
			else
				clutchInput = Mathf.Lerp(clutchInput, 0, Time.deltaTime * 10f);
		}

		if(clutchInput > 1)
			clutchInput = 1;
		if(clutchInput < 0)
			clutchInput = 0;

		//Reversing Bool.
		if(!AIController){
			if(brakeInput > .1f  && transform.InverseTransformDirection(rigid.velocity).z < 1f && canGoReverseNow && automaticGear && !changingGear && !reverseGear)
				StartCoroutine("ChangingGear", -1);
			else if(gasInput > .1f && reverseGear && !changingGear && automaticGear)
				StartCoroutine("ChangingGear", 0);
		}

		if(automaticGear){

			if(currentGear < totalGears - 1 && !changingGear && !driftingNow){
				if(speed >= (gearSpeed[currentGear] * 1.1f) && FrontLeftWheelCollider.rpm > 0){
					StartCoroutine("ChangingGear", currentGear + 1);
				}
			}
			
			if(currentGear > 0){

				if(!changingGear){

					if(speed < (gearSpeed[currentGear - 1] * .9f)){
						StartCoroutine("ChangingGear", currentGear - 1);
					}

				}

			}
			
		}else{
			
			if(currentGear < totalGears - 1 && !changingGear){
				if(Input.GetButtonDown("RCCShiftUp")){
					if(!reverseGear)
						StartCoroutine("ChangingGear", currentGear + 1);
					else
						StartCoroutine("ChangingGear", 0);
				}
			}
			
			if(currentGear >= 0){
				if(Input.GetButtonDown("RCCShiftDown")){
					StartCoroutine("ChangingGear", currentGear - 1);	
				}
			}
			
		}
		
	}
	
	IEnumerator ChangingGear(int gear){

		changingGear = true;

		if(demoGUI)
			print ("Shifted to: " + (gear).ToString()); 

		if(gearShiftingClips.Length > 0)
			gearShiftingSound = RCCCreateAudioSource.NewAudioSource(gameObject, "Gear Shifting AudioSource", 5, 5, maxGearShiftingSoundVolume, gearShiftingClips[UnityEngine.Random.Range(0, gearShiftingClips.Length)], false, true, true);
		
		yield return new WaitForSeconds(gearShiftingDelay);

		if(gear == -1){
			currentGear = 0;
			reverseGear = true;
		}else{
			currentGear = gear;
			reverseGear = false;
		}

		changingGear = false;

	}
	
	public void WheelAlign (WheelCollider wc, Transform wm, float rotation){

		RaycastHit hit;
		WheelHit CorrespondingGroundHit;

		Vector3 ColliderCenterPoint = wc.transform.TransformPoint(wc.center);
		wc.GetGroundHit(out CorrespondingGroundHit);
		
		if(Physics.Raycast(ColliderCenterPoint, -wc.transform.up, out hit, (wc.suspensionDistance + wc.radius) * transform.localScale.y) && !hit.collider.isTrigger && hit.transform.root != transform){
			wm.transform.position = hit.point + (wc.transform.up * wc.radius) * transform.localScale.y;
			float extension = (-wc.transform.InverseTransformPoint(CorrespondingGroundHit.point).y - wc.radius) / wc.suspensionDistance;
			Debug.DrawLine(CorrespondingGroundHit.point, CorrespondingGroundHit.point + wc.transform.up * (CorrespondingGroundHit.force / rigid.mass), extension <= 0.0 ? Color.magenta : Color.white);
			Debug.DrawLine(CorrespondingGroundHit.point, CorrespondingGroundHit.point - wc.transform.forward * CorrespondingGroundHit.forwardSlip * 2f, Color.green);
			Debug.DrawLine(CorrespondingGroundHit.point, CorrespondingGroundHit.point - wc.transform.right * CorrespondingGroundHit.sidewaysSlip * 2f, Color.red);
		}else{
			wm.transform.position = ColliderCenterPoint - (wc.transform.up * wc.suspensionDistance) * transform.localScale.y;
		}
		
		rotation += wc.rpm * 6 * Time.deltaTime;
		wm.transform.rotation = wc.transform.rotation * Quaternion.Euler(rotation, wc.steerAngle, wc.transform.rotation.z);
		
	}

	private float WheelRotation(WheelCollider wc, float rotation){

		rotation += wc.rpm * 6 * Time.deltaTime;
		return rotation;

	}

	public void WheelCamber (WheelCollider wc){
		
		WheelHit CorrespondingGroundHit;
		Vector3 wheelLocalEuler;

		wc.GetGroundHit(out CorrespondingGroundHit); 
		float handling = Mathf.Lerp (-2f, 2f, CorrespondingGroundHit.force / 7500f);

		if(wc.transform.localPosition.x < 0)
			wheelLocalEuler = new Vector3(wc.transform.localEulerAngles.x, wc.transform.localEulerAngles.y, (-handling));
		else
			wheelLocalEuler = new Vector3(wc.transform.localEulerAngles.x, wc.transform.localEulerAngles.y, (handling));

		Quaternion wheelCamber = Quaternion.Euler(wheelLocalEuler);
		wc.transform.localRotation = wheelCamber;
		
	}
	
	public void Dashboard (){

		if(_dashboardType == DashboardType.NGUIDashboard){
		
			if(!UIInputs){
				Debug.LogError("If you gonna use NGUI Dashboard, your NGUI Root must have ''RCCNGUIDashboardInputs''. First be sure your NGUI Root has ''RCCNGUIDashboardInputs.cs''.");
				dashBoard = false;
				return;
			}

			UIInputs.RPM = engineRPM;
			UIInputs.KMH = speed;
			UIInputs.Gear = FrontLeftWheelCollider.rpm > -10 ? currentGear : -1f;

			UIInputs.ABS = ABSAct;
			UIInputs.ESP = ESPAct;
			UIInputs.Park = handbrakeInput > .1f ? true : false;
			UIInputs.Headlights = headLightsOn;
			
			RPMNeedleRotation = (engineRPM / 50f);
			KMHNeedleRotation = (speed / 360f) * 470f;

			smoothedNeedleRotation = Mathf.Lerp (smoothedNeedleRotation, RPMNeedleRotation, Time.deltaTime * 5);
			
			RPMNeedleNGUI.transform.eulerAngles = new Vector3(RPMNeedleNGUI.transform.eulerAngles.x ,RPMNeedleNGUI.transform.eulerAngles.y, -smoothedNeedleRotation);
			KMHNeedleNGUI.transform.eulerAngles = new Vector3(KMHNeedleNGUI.transform.eulerAngles.x ,KMHNeedleNGUI.transform.eulerAngles.y, -KMHNeedleRotation);

		}

		if(_dashboardType == DashboardType.UIDashboard){
			
			if(!UIInputs){
				Debug.LogError("If you gonna use UI Dashboard, your Canvas Root must have ''RCCUIDashboardInputs''. First be sure your Canvas Root has ''RCCUIDashboardInputs.cs''.");
				dashBoard = false;
				return;
			}

			UIInputs.RPM = engineRPM;
			UIInputs.KMH = speed;
			UIInputs.Gear = FrontLeftWheelCollider.rpm > -10 ? currentGear : -1f;

			if(dashBoard && UIInputs)
				UIInputs.NGear = changingGear;
			
			UIInputs.ABS = ABSAct;
			UIInputs.ESP = ESPAct;
			UIInputs.Park = handbrakeInput > .1f ? true : false;
			UIInputs.Headlights = headLightsOn;
			
			RPMNeedleRotation = (engineRPM / 50f);
			KMHNeedleRotation = (speed * 1.25f);

			smoothedNeedleRotation = Mathf.Lerp (smoothedNeedleRotation, RPMNeedleRotation, Time.deltaTime * 5f);
			
			RPMNeedle.transform.eulerAngles = new Vector3(RPMNeedle.transform.eulerAngles.x ,RPMNeedle.transform.eulerAngles.y, -smoothedNeedleRotation);
			KMHNeedle.transform.eulerAngles = new Vector3(KMHNeedle.transform.eulerAngles.x ,KMHNeedle.transform.eulerAngles.y, -KMHNeedleRotation);
			
		}
		
	}
	
	public void SmokeWeedEveryday (GroundMaterial ground){

		for(int i = 0; i < allWheelColliders.Length; i++){

			WheelHit CorrespondingGroundHit;
			allWheelColliders[i].GetGroundHit(out CorrespondingGroundHit);

			if(_wheelSlipAsphalt.Count > 0 && ground == GroundMaterial.Asphalt){

				if(Mathf.Abs(CorrespondingGroundHit.sidewaysSlip) > .25f || Mathf.Abs(CorrespondingGroundHit.forwardSlip) > .35f){
					if(!_wheelSlipAsphalt[i].enableEmission && speed > 1)
						_wheelSlipAsphalt[i].enableEmission = true;
				}else{
					if(_wheelSlipAsphalt[i].enableEmission)
						_wheelSlipAsphalt[i].enableEmission = false;
				}

			}else if(_wheelSlipAsphalt.Count > 0){
				if(_wheelSlipAsphalt[i].enableEmission)
					_wheelSlipAsphalt[i].enableEmission = false;
			}

			if(_wheelSlipSand.Count > 0 && ground == GroundMaterial.Sand && CorrespondingGroundHit.point != Vector3.zero){
				
				if(Mathf.Abs(CorrespondingGroundHit.sidewaysSlip) > .25f || Mathf.Abs(CorrespondingGroundHit.forwardSlip) > .35f || speed > 20){
					if(!_wheelSlipSand[i].enableEmission && speed > 1)
						_wheelSlipSand[i].enableEmission = true;
				}else{
					if(_wheelSlipSand[i].enableEmission)
						_wheelSlipSand[i].enableEmission = false;
				}
				
			}else if(_wheelSlipSand.Count > 0){
				if(_wheelSlipSand[i].enableEmission)
					_wheelSlipSand[i].enableEmission = false;
			}

		}
		
		if(exhaustGas.Length > 0 && engineRunning){

			for(int i = 0; i < exhaustGas.Length; i++){
				if(speed < 30){
					if(!exhaustGas[i].enableEmission)
						exhaustGas[i].enableEmission = true;
					if(gasInput > .05f){
						exhaustGas[i].emissionRate = 25;
						exhaustGas[i].startSpeed = 5;
						exhaustGas[i].startSize = 5;
					}else{
						exhaustGas[i].emissionRate = 5;
						exhaustGas[i].startSpeed = 1;
						exhaustGas[i].startSize = 3;
					}
				}else{
					if(exhaustGas[i].enableEmission)
						exhaustGas[i].enableEmission = false;
				}
			}

		}else if(exhaustGas.Length > 0){

			for(int i = 0; i < exhaustGas.Length; i++){
				if(exhaustGas[i].enableEmission)
					exhaustGas[i].enableEmission = false;
			}

		}
		
	}

	public void DriftVariables(){
		
		WheelHit hit;
		RearRightWheelCollider.GetGroundHit(out hit);
		
		if(speed > 50f)
			driftAngle = hit.sidewaysSlip / 1f;
		else
			driftAngle = 0f;
		
		if(Mathf.Abs(hit.sidewaysSlip) > .25f)
			driftingNow = true;
		else
			driftingNow = false;

		if(_wheelTypeChoise == WheelType.DRIFT){
			if(ESP){
				Debug.Log("ESP Is Disabled For Accurate Drifting For " + transform.name);
				ESP = false;
			}
			if(TCS){
				Debug.Log("TCS Is Disabled For Accurate Drifting For " + transform.name);
				TCS = false;
			}
			if(ABS){
				Debug.Log("ABS Is Disabled For Accurate Drifting For " + transform.name);
				ABS = false;
			}
			if(steeringHelper){
				Debug.Log("Steering Helper Is Disabled For Accurate Drifting For " + transform.name);
				steeringHelper = false;
			}
		}
		
	}
	
	public void GroundPhysicsMaterial (){

		if(sleepingRigid)
			return;
		
		WheelHit wheelhit;
		RearLeftWheelCollider.GetGroundHit(out wheelhit);

		if(RearLeftWheelCollider.GetGroundHit(out wheelhit)){

			if(asphaltPhysicsMaterial){
				if(wheelhit.collider.material.name == asphaltPhysicsMaterial.name + " (Instance)")
					_groundMaterial = GroundMaterial.Asphalt;
			}if(grassPhysicsMaterial){
				if(wheelhit.collider.material.name == grassPhysicsMaterial.name + " (Instance)")
					_groundMaterial = GroundMaterial.Grass;
			}if(sandPhysicsMaterial){
				if(wheelhit.collider.material.name == sandPhysicsMaterial.name + " (Instance)")
					_groundMaterial = GroundMaterial.Sand;

			}if(UseTerrainSplatMapForGroundPhysics){

				if(wheelhit.collider.material.name == terrainPhysicsMaterial.name + " (Instance)"){

					if(TerrainSurface.GetTextureMix(RearLeftWheelCollider.transform.position)[terrainSplatMapAsphaltIndex] > .5f){
						_groundMaterial = GroundMaterial.Asphalt;
					}else if(TerrainSurface.GetTextureMix(RearLeftWheelCollider.transform.position)[terrainSplatMapGrassIndex] > .5f){
						_groundMaterial = GroundMaterial.Grass;
					}else if(TerrainSurface.GetTextureMix(RearLeftWheelCollider.transform.position)[terrainSplatMapSandIndex] > .5f){
						_groundMaterial = GroundMaterial.Sand;
					}else{
						_groundMaterial = GroundMaterial.Asphalt;
					}

				}else{
					_groundMaterial = GroundMaterial.Asphalt;
				}

			}else{
				_groundMaterial = GroundMaterial.Asphalt;
			}

		}

		if(_groundMaterial == GroundMaterial.Asphalt)
			SkidSound(asphaltSkidClip);
		else if(_groundMaterial == GroundMaterial.Grass)
			SkidSound(grassSkidClip);
		else if(_groundMaterial == GroundMaterial.Sand)
			SkidSound(sandSkidClip);

	}

	public void SkidSound(AudioClip clip){

		for(int i = 0; i < allWheelColliders.Length; i++){

			WheelHit CorrespondingGroundHit;
			allWheelColliders[i].GetGroundHit(out CorrespondingGroundHit);

			if(skidSound.clip != clip){
				skidSound.clip = clip;
			}

			if(Mathf.Abs(CorrespondingGroundHit.sidewaysSlip) > .25f || Mathf.Abs(CorrespondingGroundHit.forwardSlip) > (clip == sandSkidClip || clip == grassSkidClip ? 0f : .35f)){
				if(rigid.velocity.magnitude > 1f){
					skidSound.volume = Mathf.Lerp(
						skidSound.volume, 
						Mathf.Clamp((Mathf.Abs(CorrespondingGroundHit.sidewaysSlip)) + (clip == sandSkidClip || clip == grassSkidClip ? speed / 100f : Mathf.Abs(CorrespondingGroundHit.forwardSlip)), 0f, maxSkidSoundVolume), 
						Time.deltaTime * 30f
						);
				}else{
					skidSound.volume -= Time.deltaTime * 1.5f;
				}
				if(!skidSound.isPlaying)
					skidSound.Play();
			}else{
				skidSound.volume -= Time.deltaTime * 1.5f;
				if(skidSound.volume < .05f && skidSound.isPlaying)
					skidSound.Stop();
			}

		}

	}
	
	public void ResetCar (){
		
		if(speed < 5 && !rigid.isKinematic){
			
			if(transform.eulerAngles.z < 300 && transform.eulerAngles.z > 60){
				resetTime += Time.deltaTime;
				if(resetTime > 3){
					transform.rotation = Quaternion.identity;
					transform.position = new Vector3(transform.position.x, transform.position.y + 3, transform.position.z);
					resetTime = 0f;
				}
			}
			
			if(transform.eulerAngles.x < 300 && transform.eulerAngles.x > 60){
				resetTime += Time.deltaTime;
				if(resetTime > 3){
					transform.rotation = Quaternion.identity;
					transform.position = new Vector3(transform.position.x, transform.position.y + 3, transform.position.z);
					resetTime = 0f;
				}
			}
			
		}
		
	}
	
	void OnCollisionEnter (Collision collision){
		
		if (collision.contacts.Length < 1 || collision.relativeVelocity.magnitude < minimumCollisionForce)
			return;

			if(crashClips.Length > 0){
				if (collision.contacts[0].thisCollider.gameObject.transform != transform.parent){
					crashSound = RCCCreateAudioSource.NewAudioSource(gameObject, "Crash Sound AudioSource", 5, 20, maxCrashSoundVolume, crashClips[UnityEngine.Random.Range(0, crashClips.Length)], false, true, true);
				}
			}

		if(useDamage){

			CollisionParticles(collision.contacts[0].point);
			
			Vector3 colRelVel = collision.relativeVelocity;
			colRelVel *= 1f - Mathf.Abs(Vector3.Dot(transform.up,collision.contacts[0].normal));
			
			float cos = Mathf.Abs(Vector3.Dot(collision.contacts[0].normal, colRelVel.normalized));

			if (colRelVel.magnitude * cos >= minimumCollisionForce){
				
				sleep = false;
				
				localVector = transform.InverseTransformDirection(colRelVel) * (damageMultiplier / 50f);

				if (originalMeshData == null)
					LoadOriginalMeshData();
				
				for (int i = 0; i < deformableMeshFilters.Length; i++){
					DeformMesh(deformableMeshFilters[i].mesh, originalMeshData[i].meshVerts, collision, cos, deformableMeshFilters[i].transform, rot);
				}
				
			}

		}

	}
	
	public void Chassis (){

		if(sleepingRigid)
			return;

		if(rigid.centerOfMass != transform.InverseTransformPoint(COM.transform.position))
			rigid.centerOfMass = transform.InverseTransformPoint(COM.transform.position);

		verticalLean = Mathf.Clamp(Mathf.Lerp (verticalLean, rigid.angularVelocity.x * chassisVerticalLean, Time.deltaTime * 3f), -3.0f, 3.0f);

		WheelHit CorrespondingGroundHit;
		RearRightWheelCollider.GetGroundHit(out CorrespondingGroundHit);

		float normalizedLeanAngle = Mathf.Clamp(CorrespondingGroundHit.sidewaysSlip, -1f, 1f);

		if(normalizedLeanAngle >= 0f)
			normalizedLeanAngle = 1;
		else
			normalizedLeanAngle = -1;

		if(transform.InverseTransformDirection(rigid.velocity).z >= 0)
			horizontalLean = Mathf.Clamp(Mathf.Lerp (horizontalLean, (transform.InverseTransformDirection(rigid.angularVelocity).y) * chassisHorizontalLean, Time.deltaTime * 3f), -3f, 3f);
		else
			horizontalLean = Mathf.Clamp(Mathf.Lerp (horizontalLean, (Mathf.Abs (transform.InverseTransformDirection(rigid.angularVelocity).y) * -normalizedLeanAngle) * chassisHorizontalLean, Time.deltaTime * 3f), -3.0f, 3.0f);

		if(float.IsNaN(verticalLean) || float.IsNaN(horizontalLean) || float.IsInfinity(verticalLean) || float.IsInfinity(horizontalLean) || Mathf.Approximately(verticalLean, 0f) || Mathf.Approximately(horizontalLean, 0f))
			return;

		Quaternion target = Quaternion.Euler(verticalLean, chassis.transform.localRotation.y + (rigid.angularVelocity.z), horizontalLean);
		chassis.transform.localRotation = target;

	}
	
	public void Lights (){

		if(brakeInput > .1f){
			brakeLightInput = Mathf.Lerp(brakeLightInput, 1f, Time.deltaTime * 50f);
		}else{
			if(!headLightsOn)
				brakeLightInput = Mathf.Lerp(brakeLightInput, 0f, Time.deltaTime * 50f);
			else
				brakeLightInput = Mathf.Lerp(brakeLightInput, .3f, Time.deltaTime * 50f);
		}

		if(Input.GetKeyDown(KeyCode.L) && !AIController){
			headLightsOn = !headLightsOn;
		}
		
		for(int i = 0; i < brakeLights.Length; i++){
			
			if(!reverseGear){
				brakeLights[i].intensity = brakeLightInput;
			}else{
				if(!headLightsOn)
					brakeLights[i].intensity = 0f;
				else
					brakeLights[i].intensity = Mathf.Lerp(brakeLights[i].intensity, .3f, Time.deltaTime * 50f);
			}

		}
		
		for(int i = 0; i < headLights.Length; i++){
			
			if(headLightsOn)
				headLights[i].enabled = true;
			else
				headLights[i].enabled = false;
			
		}
		
		for(int i = 0; i < reverseLights.Length; i++){
			
			if(!reverseGear)
				reverseLights[i].intensity = Mathf.Lerp (reverseLights[i].intensity, 0f, Time.deltaTime * 50f);
			else
				reverseLights[i].intensity = brakeLightInput;
			
		}
		
	}
	
	void OnGUI (){

		if(demoGUI){

			GUI.skin.label.fontSize = 12;
			GUI.skin.box.fontSize = 12;
			
			GUI.backgroundColor = Color.gray;
			float guiWidth = Screen.width / 2f;
			
			GUI.Box(new Rect(Screen.width - 400 - guiWidth, 10, 800, 270), "");
			
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 10, 400, 150), "Engine RPM : " + Mathf.CeilToInt(engineRPM));
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 10, 400, 150), "Engine Running : " + (engineRunning == true ? "Running" : "Stopped").ToString());
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 30, 400, 150), "Engine Starter : " + (engineStarting == true ? "Starting" : "Stopped").ToString());
			
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 90, 400, 150), "Engine Sound On Volume: " + engineSoundOn.volume.ToString("F1"));
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 110, 400, 150), "Engine Sound On Pitch: " + engineSoundOn.pitch.ToString("F1"));
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 130, 400, 150), "Engine Sound Off Volume: " + engineSoundOff.volume.ToString("F1"));
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 150, 400, 150), "Engine Sound Off Pitch: " + engineSoundOff.pitch.ToString("F1"));


			
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 30, 400, 150), "Speed (KM/H) : " + Mathf.CeilToInt(speed));
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 50, 400, 150), "Steer Angle : " + Mathf.CeilToInt(FrontLeftWheelCollider.steerAngle));
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 70, 400, 150), "Automatic Shifting : " + (automaticGear == true ? "Automatic" : "Manual").ToString());

			if(!changingGear)
				GUI.Label(new Rect(Screen.width - 390 - guiWidth, 90, 400, 150), "Gear No : " + (reverseGear != true ? (currentGear + 1).ToString() : "R").ToString());
			else
				GUI.Label(new Rect(Screen.width - 390 - guiWidth, 90, 400, 150), "Gear No : " + "N");	
			
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 230, 400, 150), "Mobile Horizontal Tilt : " + Input.acceleration.x);
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 250, 400, 150), "Mobile Vertical Tilt : " + Input.acceleration.y);
			
			//Front Wheels
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 10, 400, 150), "Front Left Wheel RPM : " + Mathf.CeilToInt(FrontLeftWheelCollider.rpm));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 10, 400, 150), "Front Right Wheel RPM : " + Mathf.CeilToInt(FrontRightWheelCollider.rpm));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 30, 400, 150), "Front Left Wheel Torque : " + Mathf.CeilToInt(FrontLeftWheelCollider.motorTorque));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 30, 400, 150), "Front Right Wheel Torque : " + Mathf.CeilToInt(FrontRightWheelCollider.motorTorque));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 50, 400, 150), "Front Left Wheel brake : " + Mathf.CeilToInt(FrontLeftWheelCollider.brakeTorque));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 50, 400, 150), "Front Right Wheel brake : " + Mathf.CeilToInt(FrontRightWheelCollider.brakeTorque));
			
			WheelHit hit;
			FrontLeftWheelCollider.GetGroundHit(out hit);

			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 190, 400, 150), "Speed: " + speed);
			GUI.Label(new Rect(Screen.width - 200 - guiWidth, 210, 400, 150), "WCSpeed: " + wheelRPMToSpeed);
			
			if(FrontLeftWheelCollider.GetGroundHit(out hit)){
				GUI.Label(new Rect(Screen.width - 200 - guiWidth, 50, 400, 150), "Ground Material : " + _groundMaterial.ToString());
				GUI.Label(new Rect(Screen.width - 200 - guiWidth, 70, 400, 150), "Ground Grip : " + FrontLeftWheelCollider.forwardFriction.stiffness);
			}
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 70, 400, 150), "Front Left Wheel Force : " + Mathf.CeilToInt(hit.force));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 90, 400, 150), "Front Left Wheel Sideways Grip : " + (1 - Mathf.Abs(hit.sidewaysSlip)).ToString("F2"));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 110, 400, 150), "Front Left Wheel Forward Grip : " + (1 - Mathf.Abs(hit.forwardSlip)).ToString("F2"));
			
			FrontRightWheelCollider.GetGroundHit(out hit);
			
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 70, 400, 150), "Front Right Wheel Force : " + Mathf.CeilToInt(hit.force));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 90, 400, 150), "Front Right Wheel Sideways Grip : " + (1 - Mathf.Abs(hit.sidewaysSlip)).ToString("F2"));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 110, 400, 150), "Front Right Wheel Forward Grip : " +(1 - Mathf.Abs(hit.forwardSlip)).ToString("F2"));
			
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 170, 400, 150), "ABS: " + ABS + ". Current State: " + (ABSAct == true ? "Engaged" : "Safe").ToString());
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 190, 400, 150), "TCS: " + TCS + ". Current State: " + (TCSAct == true ? "Engaged" : "Safe").ToString());
			GUI.Label(new Rect(Screen.width - 390 - guiWidth, 210, 400, 150), "ESP: " + ESP + ". Current State: " + (ESPAct == true ? "Engaged" : "Safe").ToString());
			
			//Rear Wheels
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 150, 400, 150), "Rear Left Wheel RPM : " + Mathf.CeilToInt(RearLeftWheelCollider.rpm));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 150, 400, 150), "Rear Right Wheel RPM : " + Mathf.CeilToInt(RearRightWheelCollider.rpm));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 170, 400, 150), "Rear Left Wheel Torque : " + Mathf.CeilToInt(RearLeftWheelCollider.motorTorque));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 170, 400, 150), "Rear Right Wheel Torque : " + Mathf.CeilToInt(RearRightWheelCollider.motorTorque));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 190, 400, 150), "Rear Left Wheel brake : " + Mathf.CeilToInt(RearLeftWheelCollider.brakeTorque));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 190, 400, 150), "Rear Right Wheel brake : " + Mathf.CeilToInt(RearRightWheelCollider.brakeTorque));
			
			RearLeftWheelCollider.GetGroundHit(out hit);
			
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 210, 400, 150), "Rear Left Wheel Force : " + Mathf.CeilToInt(hit.force));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 230, 400, 150), "Rear Left Wheel Sideways Grip : " + (1 - Mathf.Abs(hit.sidewaysSlip)).ToString("F2"));
			GUI.Label(new Rect(Screen.width + 00 - guiWidth, 250, 400, 150), "Rear Left Wheel Forward Grip : " + (1 - Mathf.Abs(hit.forwardSlip)).ToString("F2"));
			
			RearRightWheelCollider.GetGroundHit(out hit);
			
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 210, 400, 150), "Rear Right Wheel Force : " + Mathf.CeilToInt(hit.force));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 230, 400, 150), "Rear Right Wheel Sideways Grip : " + (1 - Mathf.Abs(hit.sidewaysSlip)).ToString("F2"));
			GUI.Label(new Rect(Screen.width + 200 - guiWidth, 250, 400, 150), "Rear Right Wheel Forward Grip : " + (1 - Mathf.Abs(hit.forwardSlip)).ToString("F2"));
			
			GUI.backgroundColor = Color.green;
			GUI.Button (new Rect(Screen.width-20 - guiWidth, 260, 10, Mathf.Clamp((-gasInput * 100), -100, 0)), "");
			
			GUI.backgroundColor = Color.red;
			GUI.Button (new Rect(Screen.width-35 - guiWidth, 260, 10, Mathf.Clamp((-brakeInput * 100), -100, 0)), "");
			
			GUI.backgroundColor = Color.blue;
			GUI.Button (new Rect(Screen.width-50 - guiWidth, 260, 10, Mathf.Clamp((-clutchInput * 100), -100, 0)), "");
			
		}
		
		if(canControl){
			
			if(useAccelerometerForSteer && mobileController){

				if(_mobileControllerType == MobileGUIType.NGUIController){
					if(leftArrowNGUI){
						if(leftArrowNGUI.gameObject.activeSelf)
							leftArrowNGUI.gameObject.SetActive(false);
					}
					if(rightArrowNGUI){
						if(rightArrowNGUI.gameObject.activeSelf)
							rightArrowNGUI.gameObject.SetActive(false);
					}
					if(handbrakeNGUI){
						if(!handbrakeNGUI.gameObject.activeSelf)
							handbrakeNGUI.gameObject.SetActive(true);
					}
					if(brakePedalNGUI){
						brakePedalNGUI.transform.position = leftArrowNGUI.transform.position;
					}
				}

				if(_mobileControllerType == MobileGUIType.UIController){
					if(leftArrowUI){
						if(leftArrowUI.gameObject.activeSelf)
							leftArrowUI.gameObject.SetActive(false);
					}
					if(rightArrowUI){
						if(rightArrowUI.gameObject.activeSelf)
							rightArrowUI.gameObject.SetActive(false);
					}
					if(handbrakeUI){
						if(!handbrakeUI.gameObject.activeSelf)
							handbrakeUI.gameObject.SetActive(true);
					}
					if(brakePedalUI){
						brakePedalUI.transform.position = leftArrowUI.transform.position;
					}
				}

				steeringWheelControl = false;

			}else if(mobileController){

				if(_mobileControllerType == MobileGUIType.NGUIController){

					if(gasPedalNGUI){
						if(!gasPedalNGUI.gameObject.activeSelf)
							gasPedalNGUI.gameObject.SetActive(true);
					}
					if(brakePedalNGUI){
						if(!brakePedalNGUI.gameObject.activeSelf)
							brakePedalNGUI.gameObject.SetActive(true);
					}
					if(leftArrowNGUI){
						if(!leftArrowNGUI.gameObject.activeSelf)
							leftArrowNGUI.gameObject.SetActive(true);
					}
					if(rightArrowNGUI){
						if(!rightArrowNGUI.gameObject.activeSelf)
							rightArrowNGUI.gameObject.SetActive(true);
					}
					if(handbrakeNGUI){
						if(!handbrakeNGUI.gameObject.activeSelf)
							handbrakeNGUI.gameObject.SetActive(true);
					}
					if(brakePedalNGUI){
						brakePedalNGUI.transform.position = defbrakePedalPosition;
					}

				}

				if(_mobileControllerType == MobileGUIType.UIController){

					if(gasPedalUI){
						if(!gasPedalUI.gameObject.activeSelf)
							gasPedalUI.gameObject.SetActive(true);
					}
					if(brakePedalUI){
						if(!brakePedalUI.gameObject.activeSelf)
							brakePedalUI.gameObject.SetActive(true);
					}
					if(leftArrowUI){
						if(!leftArrowUI.gameObject.activeSelf)
							leftArrowUI.gameObject.SetActive(true);
					}
					if(rightArrowUI){
						if(!rightArrowUI.gameObject.activeSelf)
							rightArrowUI.gameObject.SetActive(true);
					}
					if(handbrakeUI){
						if(!handbrakeUI.gameObject.activeSelf)
							handbrakeUI.gameObject.SetActive(true);
					}
					if(brakePedalUI){
						brakePedalUI.transform.position = defbrakePedalPosition;
					}
				}

			}
			
			if(steeringWheelControl && mobileController){

				if(_mobileControllerType == MobileGUIType.NGUIController){
					if(leftArrowNGUI){
						if(leftArrowNGUI.gameObject.activeSelf)
							leftArrowNGUI.gameObject.SetActive(false);
					}
					if(rightArrowNGUI){
						if(rightArrowNGUI.gameObject.activeSelf)
							rightArrowNGUI.gameObject.SetActive(false);
					}
				}

				if(_mobileControllerType == MobileGUIType.UIController){
					if(leftArrowUI){
						if(leftArrowUI.gameObject.activeSelf)
							leftArrowUI.gameObject.SetActive(false);
					}
					if(rightArrowUI){
						if(rightArrowUI.gameObject.activeSelf)
							rightArrowUI.gameObject.SetActive(false);
					}
				}

			}

			if(showMobileControllerChangerButtons && canControl){
				
				if(GUI.Button(new Rect(Screen.width - 275, Screen.height / 2 - 35, 250, 50), "Use Accelerometer \n For Steer")){
					useAccelerometerForSteer = !useAccelerometerForSteer;
				}
				
				if(GUI.Button(new Rect(Screen.width - 275, Screen.height / 2 + 35, 250, 50), "Use Steering Wheel \n For Steer")){
					steeringWheelControl = !steeringWheelControl;
				}
				
			}

		}
		
	}

	private bool OverTorque(){

		if(speed > maxspeed || !engineRunning)
			return true;
		
		if(reverseGear && speed > 55)
			return true;
		
		if(!engineRunning)
			return true;

		return false;

	}

	void OnDrawGizmos(){
#if UNITY_EDITOR
		if(Application.isPlaying){

			WheelHit hit;

			for(int i = 0; i < allWheelColliders.Length; i++){

				allWheelColliders[i].GetGroundHit(out hit);

				Matrix4x4 temp = Gizmos.matrix;
				Gizmos.matrix = Matrix4x4.TRS(allWheelColliders[i].transform.position, Quaternion.AngleAxis(-90, Vector3.right), Vector3.one);
				Gizmos.color = new Color((hit.force / rigid.mass) / 5f, (-hit.force / rigid.mass) / 5f, 0f);
				Gizmos.DrawFrustum(Vector3.zero, 2f, hit.force / rigid.mass, .1f, 1f);
				Gizmos.matrix = temp;

			}

		}
#endif
	}

	//Events Initialization For Steering Wheel.
	void SteeringWheelEventsInit(){

		eventTrigger = steeringWheelGameObject.GetComponent<EventTrigger>();
		
		var a = new EventTrigger.TriggerEvent();
		a.AddListener( data => 
		              {
			var evData = (PointerEventData)data;
			data.Use();
			
			steeringWheelPressed = true;
			steeringWheelTouchPos = evData.position;
			steeringWheelTempAngle = Vector2.Angle(Vector2.up, evData.position - steeringWheelCenter);
		});
		
		eventTrigger.triggers.Add(new EventTrigger.Entry{callback = a, eventID = EventTriggerType.PointerDown});
		
		
		var b = new EventTrigger.TriggerEvent();
		b.AddListener( data => 
		              {
			var evData = (PointerEventData)data;
			data.Use();
			steeringWheelTouchPos = evData.position;
		});
		
		eventTrigger.triggers.Add(new EventTrigger.Entry{callback = b, eventID = EventTriggerType.Drag});
		
		
		var c = new EventTrigger.TriggerEvent();
		c.AddListener( data => 
		              {
			steeringWheelPressed = false;
		});
		
		eventTrigger.triggers.Add(new EventTrigger.Entry{callback = c, eventID = EventTriggerType.EndDrag});

	}

	public float GetSteeringWheelInput(){

		return Mathf.Round(steeringWheelAngle / steeringWheelMaximumsteerAngle * 100) / 100;

	}

	public bool isSteeringWheelPressed(){

		return steeringWheelPressed;

	}
	
} 
